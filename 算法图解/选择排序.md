# 选择排序

## 内存的工作原理

> 计算机就像是很多抽屉的集合体，每个抽屉都有地址。

需要将数据存储到内存是，计算机会给数据分配一块内存，并提供一个存储地址。

## 数组和链表

数组和链表都可以存储多项数据，但是在内存中的存储方式完全不一样。

_数组_ 意味着所有数据在内存中都是紧密相连的（紧靠在一起，地址连续）。

在数组中添加元素时，如果后续内存地址已经被占用，则需要将整个数组移动内存的其他地方，以保证有足够的空间来容纳数组元素。从而也导致了在数组中添加新元素的速度会**很慢**。

其中一种解决办法就是“预留座位”。这也是很多编程语言中的做法，创建数组时需要传递数组的长度作为参数。虽然解决了问题，但是也存在缺点：

- 额外的位置可能根本用不上，浪费内存
- 如果超过了“预留座位”的长度，还是要转移

_链表_ 很好的解决了这个问题。因为链表在内存中并不是连续的。它不会因为后续内存空间不足而需要移动元素。

链表中的每个元素都存储了下一个元素的地址，从而使一些列随机的内存地址串在一起。

链表在插入元素时，根本不需要移动元素，因为链表在内存中不连续，只需要将新元素放入内存中，然后将其地址存储到前一个元素中即可。

但是正因为链表在内存中地址不连续，所以没办法通过第一个元素计算出后续元素的位置，导致在随机读取链表中元素时，必须从链表的一个元素开始遍历。链表在同时读取所有元素时，效率很高，但是如果需要跳跃读取，效率就不好了。

而数组不同，数组中每个元素的位置都可以根据第一个元素的地址计算出来，在随机读取元素时，效率很高，可以迅速找到数组中的任何元素。

数组和链表对比：

|      | 优势     | 劣势     |
| ---- | -------- | -------- |
| 链表 | 插入元素 | 读取元素 |
| 数组 | 读取元素 | 插入元素 |

数组和链表操作的运行时间：

> O(n) = 线性时间；O(1) = 常量时间

|      | 数组 | 链表 |
| ---- | ---- | ---- |
| 读取 | O(1) | O(n) |
| 插入 | O(n) | O(1) |
| 删除 | O(n) | O(1) |

## 选择排序 —— Selection sort

选择排序是一种灵巧的算法，但其速度并不是很快。

原理：首先在未排序的序列中找到最小（大）的元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。一次类推，知道所有的元素排序完毕。

选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序梅子交换一对元素，它们当中至少有一个被移动到其最终位置上，因此对 n 个元素的表进行排序总共进行之多 n - 1 次交换。在所有的完全依靠交换去移动元素的排序算法中，选择排序属于非常好的一种。

### 实现

```py
def selection_sort(arr):
  for i in range(len(arr)):
    minIndex = i
    for j in (rang(i + 1, len(arr))):
      if arr[minIndex] > arr[j]
        minIndex = j
    if i == minIndex:
      pass
    else:
      arr[i], arr[minIndex] = arr[minIndex], arr[i]
  return arr
```

```js
function selectionSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    let minIndex = i;
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[minIndex] > arr[j]) {
        minIndex = j;
      }
    }
    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
  }
  return arr;
}
```

### 复杂度分析

选择排序的**交换操作**介于 0 和 n - 1 次之间。选择排序的**比较操作**为 n(n-1) / 2 次。选择排序的**赋值操作**介于 0 和 3(n - 1)次之间。

比较次数 O($n^2$)，比较次数与关键字的初始状态无关，总的比较次数 N = (n - 1) + (n - 2) + ... + 1 = n(n - 1) / 2。

交换次数 O(n)，最好情况是，已经有序，交换 0 次；最坏情况时，逆序，交换 n - 1 次。交换次数比冒泡排序较少，由于交换所需 CPU 时间比比较所需的 CPU 时间多，n 值较小时，选择排序比冒泡排序快。

## 总结

- 计算机内存犹如一大堆抽屉。
- 需要存储多个元素时，可以使用数组或链表。
- 数据的元素都在一起（内存连续）。
- 链表的元素时分开的，其中每个元素都存储了下一个元素的地址。
- 数组的读取（随机读取）速度很快。
- 链表的插入和删除速度很快。
- 在同一个数组中，所有的元素的类型都必须相同（js 出外）。
