# JS 基础知识点及常考面试题（二）

## 宽松相等(==)和严格相等(===)

> == 允许在相等比较重进行强制类型转换，而 === 不允许

在宽松相等中，如果两个值的类型相同，就仅比较他们是否相等，如果类型不同，则对其中之一或者两者都进行强制类型转换。

### 字符串和数字之间的相等比较

- 如果`Type(x)`是数字，`Type(y)`是字符串，则返回`x == ToNumber(y)`的结果。
- 如果`Type(x)`是字符串，`Typex(x)`是数字，则返回`ToNumber(x) == y`的结果。

### 其它类型和布尔类型之间的相等比较

- 如果`Type(x)`是布尔类型，则返回`ToNumber(x) == y`的结果。
- 如果`Type(y)`是布尔类型，则返回`x == ToNumber(y)`的结果。

### null 和 undefined 之间的相等比较

- 如果 x 为 null，y 为 undefined，则结果为 true。
- 如果 x 为 undefined，x 为 null， 则结果为 true。

### 对象和非对象之间的相等比较

- 如果`Type(x)`是字符串或数字，`Type(y)`是对象，则返回`x == ToPrimitive(y)`的结果。
- 如果`Type(x)`是对象，`Type(y)`是字符串或数字，则返回`ToPrimitive(x) == y`的结果。

## 闭包

闭包是就词法作用域书写代码时所产生的的自然结果。

当函数可以记住并访问所在的词法作用于时，就产生了闭包，即使函数时在当前词法作用域之外执行。

NOTE：**词法作用域就是定义在词法阶段的作用域，换句话说，词法作用域就是在写代码时将变量和块作用域写在哪里来决定的**

```js
function foo() {
  var a = 2;

  function bar() {
    console.log(a);
  }

  return bar;
}

var baz = foo();
baz(); // 调用bar函数， 输出2
```

`foo`函数执行后，其内部作用域会被垃圾回收机制销毁，但是由于`bar`函数声明的位置，它拥有了`foo()`函数内部的作用域闭包，从而阻止了`foo`函数内部作用域销毁，使得该作用域能够一直存活，以供`bar()`在之后任何时间进行引用。

`bar()`依然持有对该作用域的引用，而这个引用就叫做闭包。

函数在定义是的词法作用域以外的地方被调用，闭包使得函数可以继续访问定义时的词法作用域。

无论使用任何方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。

NOTE：**无论通过何种手段将内部函数传递到所在词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包**

## 深拷贝 vs 浅拷贝

对于浅拷贝，对象类型只会复制引用，而不是复制值，深拷贝是不管是原始类型，还是对象类型，都进行值的复制，但是有可能因循环引用导致死循环。

`Object.assign()`实现的是浅拷贝。

对于 JSON 安全（也就是说可以被序列化为一个 JSON 字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象）的对象来说，可以使用`JSON.parse(JSON.stringify(obj))`实现深拷贝。

- 会忽略`undefined`
- 会忽略`symbol`
- 不能序列化函数
- 不能解决循环引用的对象

[loadsh.cloneDeep](https://lodash.com/docs#cloneDeep)

## 原型

JavaScript 中的对象有一个特殊的`[[Prototype]]`内置属性，其实就是对于其他对象的引用。几乎所有对象在创建时`[[Prototype]]`属性都会被赋予一个非空的值。

所有的函数默认都会拥有一个名为`prototype`的共有且不可枚举的属性，它会指向另一个对象：这个对象在调用构造函数时创建，并被关联到构造函数的`prototype`对象上。

在面向对象语言中，类是可以别复制多次的，但是在 JavaScript 中，并没哟类似的复制机制，多个对象的`[[Prototype]]`关联的是同一个对象。

```js
function Foo() {}

var a = new Foo();

Object.getPrototype(a) === Foo.prototype; // true
```

`new Foo()`会生成一个新对象，这个新对象的内部链接`[[Prototype]]`关联的就是`Foo.prototype`对象。

JavaScript 会在两个对象之间创建一个关联，这样一个对象就可以通过*委托*访问另一个对象的属性和函数。

- `Object`是所有对象的爸爸，所有对象都可以通过`[[Prototype]]`找到它。
- `Function`是多有函数的爸爸，所以函数都可以通过`[[Prototype]]`找到它。
- `Function.prototype` 和 `Object.prototype` 是两个特殊的对象，他们由引擎来创建
- 除了以上两个特殊对象，其他对象都是通过构造器 `new` 出来的
- 函数的 `prototype` 是一个对象，也就是原型
- 对象的 `[[Prototype]]` 指向原型， `[[Prototype]]` 将对象和原型连接起来组成了原型链
