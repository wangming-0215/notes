# 发布订阅模式

## 概述

**发布订阅模式**又叫**观察者模式**，定义对象之间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在JavaScript中，一般使用事件模型替代传统的发布订阅模式。

## 作用

- 发布订阅模式可以广泛应用于异步编程中，这是一种替代传统毁掉函数的方案。
- 发布订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显示地调用另一个对象的某个接口，使两个对象松耦合地联系在一起。

## 实现

1. 首先要制定好谁充当发布者
2. 然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者
3. 最后发布消息的时候，发布者回便利这个缓存列表，依次触发里面存放的订阅者回调函数

```js
class EventEmitter {
  constructor() {
    this._events = {};
  }

  // 订阅事件
  on(event, callback) {
    if (!this._events[event]) {
      this._events[event] = [];
    }
    this._events[event].push(callback);
  }

  // 发布事件
  emit(event, ...args) {
    // 一次调用订阅者回调函数
    this._events[event].forEach(fn => fn(...args));
  }

  // 取消订阅
  // 注意，此处 callback 与订阅是的 callback 为同一引用。
  off(event, callback) {
    if (!callback) {
      // 如果没传 callback，则取消该事件的所有订阅
      this._events[event] = [];
    } else {
      // 从回调数组中移除对应的 callback;
      this._events = this._events.filter(c => c !== callback);
    }
  }

}
```

## 先订阅再发布

建立一个存放离线事件的堆栈，当事件发布的时候，如果此时还没有订阅者来订阅事件，暂时把发布事件的动作包裹在一个函数里，等有对象来订阅此事件的时候，再遍历推展并且一次执行函数，也就是重新发布里面的事件。（难道是**代理模式**？）

> 具体实现见书第 121 页。

## 总结

### 优点

- 时间上解耦，一旦订阅，任何时候出发都可以
- 对象之间解耦

### 缺点

- 创建订阅者本身要消耗一定的事件和内存，而且一旦订阅，这个订阅对象就始终存在于内存中，
- 过度使用，导致对象和对象之间的必要联系被深埋在背后，从而那一追踪维护和理解。